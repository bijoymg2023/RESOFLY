# Walkthrough - Phase 1: Alerts System (SQLite)

I have successfully implemented the **Alerts System** using the "Edge" architecture (SQLite) as requested.

## Architecture Change
- **Database**: Switched from MongoDB to **SQLite** (`thermo_vision.db`) to match the Raspberry Pi "Edge" requirement.
- **ORM**: Used `SQLAlchemy` with `aiosqlite` for async database access.

## Implemented Features
1.  **Backend API (`server.py`)**:
    -   `GET /api/alerts`: Returns list of alerts (sorted by time).
    -   `POST /api/alerts`: Creates a new alert.
    -   `PATCH /api/alerts/{id}/acknowledge`: Marks an alert as read.
    -   `DELETE /api/alerts/{id}`: Deletes an alert.

2.  **Frontend (`AlertBox.tsx`)**:
    -   Connected to API using `React Query`.
    -   Polls for new alerts every **5 seconds**.
    -   "ACK" and "Dismiss" buttons now function by calling the API.

## Verification
I verified the API using `curl`:

```bash
# Create an Alert
curl -X POST "http://127.0.0.1:8000/api/alerts" -H "Content-Type: application/json" -d '{"type": "warning", "title": "Test Alert", "message": "This is a test from curl"}'

# Get Alerts
curl http://127.0.0.1:8000/api/alerts
```

## Phase 2: Video Stream
I have implemented a **Mock Thermal Stream** (MJPEG) that simulates the FLIR Lepton 3.5 output.
- **Backend**:
  - `GET /api/stream/thermal`: Streams dynamic MJPEG frames generated by `backend/camera.py`.
  - Simulates a "hotspot" moving across the frame using `numpy` and `opencv`.
- **Frontend**:
  - `VideoStreamBox` updated to display the live stream when "Thermal" is selected.

## Verification
- **Alerts**: Verified partial update (ACK) using `curl`.
- **Stream**: Verified stream connection and data transfer (~130KB in 3 seconds).

```bash
# Verify stream
curl -v http://127.0.0.1:8000/api/stream/thermal > test.mjpeg
```

## Phase 3: GPS & System Status
I have integrated **real-time system monitoring** and **mock GPS tracking**.
- **Backend**:
  - `GET /api/gps`: Returns mocked coordinates (simulating movement around NYC).
  - `GET /api/system-status`: Uses `psutil` to return CPU, Memory, Disk, Uptime, and Cpu Temp (mocked for Mac).
- **Frontend**:
  - `GPSCoordinateBox`: Fetches `/api/gps` (1s poll).
  - `ThermalDashboard`: Fetches `/api/system-status` (5s poll) and displays health badges.

## Verification
- **System Status**: Verified JSON output from `curl`.
```bash
curl http://127.0.0.1:8000/api/system-status
# Output: {"cpu_usage": 12.5, "memory_usage": 45.2, ...}
```

## Phase 4: Production Readiness
I have made the system **Offline** and **Auto-Boot** capable.
- **Frontend Refactor**: Converted all API calls to relative paths (`/api/...`).
- **Single-Process Deployment**: The Python backend now serves the Frontend `dist` folder directly.
- **Boot Script**: Created `thermo-vision.service` for systemd.

## Verification
- **Production Build**: Ran `npm run build` and verified `curl http://127.0.0.1:8000/` returns the React HTML.
- **API Proxy**: Verified that `/api` routes work alongside the static frontend.

## Next Steps
- Copy the code to Raspberry Pi using the **Deployment Guide**.
- Enable the service with `sudo systemctl enable resofly.service`.

> [!IMPORTANT]
> **DEPLOYMENT**: Please refer to [DEPLOYMENT.md](file:///Users/bijoymathewgeorge/.gemini/antigravity/brain/4fff4f0c-8655-4ffb-a82f-9ec47a49f908/DEPLOYMENT.md) for detailed instructions on installing libraries (`pylepton`, `pyserial`) and configuring the Raspberry Pi.
